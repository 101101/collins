<h2>Design</h2>

<p>
  The initial design goal was that the entire API should be usable from the command line, even
  with netcat. To that end, basic auth is used for HTTP authentication, and curl is an adequate client
  interface as long as you're inclined. There are no plans to ever use OAuth or a similar authentication
  mechanism.
</p>

<p>
  The collins API has two nice features. First, it is as RESTful as it could be
  without being an ass. Status codes are used to indicate what happened
  uniformly, appropriate HTTP methods (PUT, GET, etc) for each endpoint,
  plural/singular endpoints as you would expect, etc. Second, you can request
  the output for any API endpoint as plain text, JSON, or bash (sh compatible).
</p>

<h2>Conventions</h2>

<h3>Basics</h3>
<ul>
  <li>Basic auth is used for all HTTP endpoints</li>
  <li>A URI describes a resource</li>
  <li>PUT creates a resource</li>
  <li>POST modifies a resource</li>
  <li>DELETE kills a resource</li>
</ul>

<h3>Status Codes</h3>
<p>
  Note that some status codes listed below won't be listed in the documentation.
  Status codes 400, 401, 405 and 500 will never be documented. You will always
  get an HTTP 400 if there is a bad parameter, you will always get an HTTP 401
  if you fail to authenticate, you will always get an HTTP 405 if you use the
  wrong verb, and you will always get an HTTP 500 if there is an internal server
  error. I am stating this once to avoid restating it dozens of times in the
  internal docs.
</p>
<table class="table-hover table-condensed">
  <thead>
    <tr><td>Code</td><td>Use</td></tr>
  </thead>
  <tbody>
    <tr><th>200</th><td>Normal operation, expect this</td></tr>
    <tr><th>201</th><td>Resource created, all PUT calls should return this on success</td></tr>
    <tr><th>202</th><td>Resource accepted for deletion</td></tr>
    <tr><th>400</th><td>Bad input found, modify your request and try again</td></tr>
    <tr><th>401</th><td>You failed to authenticate successfully, retry using different credentials</td></tr>
    <tr><th>403</th><td>You do not have appropriate privileges to perform the specified operation</td></tr>
    <tr><th>404</th><td>Resource not found - this is a normalish response code</td></tr>
    <tr><th>405</th><td>Unsupported HTTP method - modify request before retry</td></tr>
    <tr><th>409</th><td>Performing the operation would have created a conflict (duplicate IP, duplicate name, etc)</td></tr>
    <tr><th>429</th><td>You are being rate limited, slow down</td></tr>
    <tr><th>500</th><td>An internal error occurred, you should probably try again</td></tr>
    <tr><th>501</th><td>You are trying to perform an operation that the system is not configured for</td></tr>
    <tr><th>504</th><td>If multicollins or the provision plugins are configured and a timeout occurs interacting with a remote service</td></tr>
  </tbody>
</table>

<h3>Response Formats</h3>
<p>
Use the <code>Accept</code> header to specify the output format. JSON is the default output format and in general the best to use. However,
every API endpoint has support for plain text, bash, and JSON output. The recognized accept headers for the API are:
</p>
<ul>
  <li><code>text/plain</code></li>
  <li><code>application/json</code></li>
  <li><code>text/x-shellscript</code></li>
</ul>
<p>
The <code>text/x-shellscript</code> endpoint will modify keys to make them valid POSIX variables.  Specifically, if a key starts with a digit, an underscore will be prepended to the key, Also, any special characters in a key will be replaced with underscores.

<h3>API Versioning</h3>
<p>
Collins supports API versioning via the accept header. This allows developers to make breaking changes to the API and continue to have old
clients work. This is implemented but I'll leave this to Dan to document.
</p>

<h3>Pagination</h3>
<p>
Paginated result sets always provide results in a standard format. Paginated results also always included a header with the same pagination
information that can be found in the result set. The headers with pagination information are:
</p>
<ul>
  <li><code>X-Pagination-PreviousPage</code></li>
  <li><code>X-Pagination-CurrentPage</code></li>
  <li><code>X-Pagination-NextPage</code></li>
  <li><code>X-Pagination-TotalResults</code></li>
</ul>
<p>
The JSON output format will return an object with a <code>Pagination</code> key and an object value. The pagination object has the following
keys: <code>PreviousPage</code>, <code>CurrentPage</code>, <code>NextPage</code>, <code>Total Results</code>.
</p>
<p>
If an API endpoint can be paginated it will be annotated with a <span class="label label-info">Paginated</span> marker. Paginated API endpoints
accept the following parameters:
</p>
<table class="table table-condensed">
  <thead>
    <tr><td>Name</td><td>Type</td><td>Description</td></tr>
  </thead>
  <tbody>
    <tr>
      <th class="inlinecode">page</th>
      <td>Option[Integer]</td>
      <td>Defaults to zero, indexed from zero. The page of results that you want.</td>
    </tr>
    <tr>
      <th class="inlinecode">size</th>
      <td>Option[Integer]</td>
      <td>Number of results to return. Generally defaults to 10.</td>
    </tr>
    <tr>
      <th class="inlinecode">sort</th>
      <td>Option[String]</td>
      <td>Valid values are "ASC" or "DESC". Generally defaults to "DESC".</td>
    </tr>
  </tbody>
</table>

<h2>Documentation Conventions</h2>
<p>
If a URI contains a colon (:) followed by text, this is a required part of the URI. This is
typically used for specifying the resource you are interacting with. For instance if a URI is documented
as <code>/api/foo/:bar</code> then <code>:bar</code> is a variable that is specified as part of the URI.
</p>
